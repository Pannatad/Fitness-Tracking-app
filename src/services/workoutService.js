import { supabase } from '../supabaseClient';

export const workoutService = {
    /**
     * Fetch custom exercises for a user
     */
    async getCustomExercises(userId) {
        const { data, error } = await supabase
            .from('exercises')
            .select('*')
            .eq('user_id', userId);

        if (error) throw error;
        return data || [];
    },

    /**
     * Add a new custom exercise
     */
    async addCustomExercise(userId, exercise) {
        const { data, error } = await supabase
            .from('exercises')
            .insert([{
                name: exercise.name,
                category: exercise.category,
                user_id: userId,
                // ID is auto-generated by Supabase if not provided, 
                // but app might generate one. Let's let Supabase handle ID 
                // and return it, or use the one from app if it's a UUID.
            }])
            .select()
            .single();

        if (error) throw error;
        return data;
    },

    /**
     * Fetch all workout history and transform into App's expected format
     * Returns: { [exerciseId]: [ { date, sets: [], ... }, ... ] }
     */
    async getHistory(userId) {
        // Fetch all sets for the user, joined with workout info
        const { data, error } = await supabase
            .from('workout_sets')
            .select(`
                *,
                workouts (
                    date,
                    start_time,
                    end_time
                )
            `)
            .eq('workouts.user_id', userId); // This filter might need to be on the join or handled by RLS

        // Note: .eq('workouts.user_id') works if RLS allows reading the workout. 
        // Better to fetch workouts first then sets, or rely on RLS.
        // Let's assume RLS filters sets by user ownership of the workout (if implemented)
        // or we filter manually if needed.

        if (error) throw error;

        // Transform flat list of sets into nested history object
        const history = {};

        if (!data) return history;

        // Group by exercise_id
        data.forEach(row => {
            if (!row.workouts) return; // Orphaned set?

            const exerciseId = row.exercise_id;
            const date = row.workouts.date;

            if (!history[exerciseId]) {
                history[exerciseId] = [];
            }

            // Find existing session for this date in our history object
            let session = history[exerciseId].find(s => s.date === date);

            if (!session) {
                session = {
                    date: date,
                    startTime: row.workouts.start_time,
                    endTime: row.workouts.end_time,
                    sets: []
                };
                history[exerciseId].push(session);
            }

            // Add set to session
            session.sets.push({
                weight: row.weight,
                reps: row.reps,
                note: row.note,
                time: row.time || row.created_at // Fallback
            });
        });

        return history;
    },

    /**
     * Save a workout session (or sets)
     * In the app, this is called when "Finish" is clicked for an exercise.
     * We create a 'workout' entry and then 'workout_sets'.
     */
    async saveLog(userId, exerciseId, logData) {
        // logData = { date, startTime, endTime, sets: [...] }

        // 1. Create Workout Entry
        const { data: workout, error: workoutError } = await supabase
            .from('workouts')
            .insert([{
                user_id: userId,
                date: logData.date,
                start_time: logData.startTime,
                end_time: logData.endTime,
                name: 'Workout' // Generic name for now
            }])
            .select()
            .single();

        if (workoutError) throw workoutError;

        // 2. Create Sets Entries
        const setsToInsert = logData.sets.map(set => ({
            workout_id: workout.id,
            exercise_id: exerciseId,
            weight: parseFloat(set.weight),
            reps: parseFloat(set.reps),
            note: set.note,
            time: set.time
        }));

        const { error: setsError } = await supabase
            .from('workout_sets')
            .insert(setsToInsert);

        if (setsError) throw setsError;

        return workout;
    },

    /**
     * Clear all data for user
     */
    async clearData(userId) {
        // Due to cascade delete, deleting user's workouts should delete sets.
        const { error } = await supabase
            .from('workouts')
            .delete()
            .eq('user_id', userId);

        if (error) throw error;

        // Also delete custom exercises? Maybe.
        // await supabase.from('exercises').delete().eq('user_id', userId);
    }
};
